<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Biweek Report 20211215~20211229</title>
    <link href="/2021/12/20/BiweekReport_20211215_20211229/"/>
    <url>/2021/12/20/BiweekReport_20211215_20211229/</url>
    
    <content type="html"><![CDATA[<h2 id="双周汇报"><a href="#双周汇报" class="headerlink" title="双周汇报"></a>双周汇报</h2><p>2021～2022学年第一学期  第15、16周（2021年12月15日～2021年12月29日）</p><p>汇报人：汤伟杰    汇报时间：2021年12月20日</p><h4 id="一、本周主要工作内容"><a href="#一、本周主要工作内容" class="headerlink" title="一、本周主要工作内容"></a>一、本周主要工作内容</h4><ul><li><p>文献阅读：根据上次文献《基于抽象语法树的代码静态缺陷检测工具开发》，继续深入阅读，查阅了相关的文献资料和参考文献。</p></li><li><p>学习工作：继续学习Vue框架，继续搭建商城项目，学习使用了Better-Scroll移动端开发滚动效果，项目地址：<a href="https://github.com/leibaio/supermall">https://github.com/leibaio/supermall</a></p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxk4ymtwguj31p40u042r.jpg" style="zoom: 28%;" /><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxk507koejj31bq0u0wk8.jpg" style="zoom: 36%;" /><p>学校挑战杯创业赛，和同组成员准备相关方案和设计工作；</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxk59to8tjj31gs0u0gu6.jpg" style="zoom:33%;" /><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxk5bae1m5j31hc0u0mzz.jpg" style="zoom:33%;" /><p>进行软件过程管理相关的知识整理；</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxkmt6mwvdj31js0u0aph.jpg" style="zoom:32%;" /><p>学习非关系型数据库Redis相关基本命令和MyBatis框架；</p><p>并行处理课程，学习相关并行算法，使用OpenMP的PSRS算法，使用MPI的Odd_Even排序以及CUDA编程；</p></li></ul><h4 id="二、阅读文献笔记及总结"><a href="#二、阅读文献笔记及总结" class="headerlink" title="二、阅读文献笔记及总结"></a>二、阅读文献笔记及总结</h4><h5 id="文献："><a href="#文献：" class="headerlink" title="文献："></a>文献：</h5><p>[1]林渤，王枭雄，胡建鹏。基于 GCC 的 C 语言抽象语法树重建与可视化研究 [J]. 软件工程与应用，2021,10 (05):654-660. DOI:10.12677/SEA.2021.105070.</p><p>[2]于屏岗，张威，肖庆。软件静态测试中 C/C++ 抽象语法树的生成 [J]. 测试技术学报，2004,18 (z5):47-50. DOI:10.3969/j.issn.1671-7449.2004.z5.014.</p><p>[3]刘文伟,刘坚.一个重建GCC抽象语法树的方法[J].计算机工程与应用,2004(18):125-128.</p><p>[4]张启航. 基于抽象语法树的代码缺陷检测技术设计与实现[D].北京邮电大学,2020.DOI:10.26969/d.cnki.gbydu.2020.002569.</p><h5 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h5><p>[1]</p><ol><li><p>抽象语法树 (Abstract Syntax Tree, AST) 是一种抽象的表示，它能以树状的形式表现出高级语言的语法结构，而不会表示出真实语法中出现的细节。作为一种中间表示形式，主要被用于预处理，因此可以应用在代码分析领域。代码经过词法分析得到字符序列，再由语法分析得到抽象语法树。抽象语法树的结构简单，根节点表示整个程序，内部节点是抽象语法结构或者单词。</p></li><li><p>GCC 生成的抽象语法树常用的节点类型大致分为 7 种，分别为声明节点 (_decl)、标识符节点 (identifier_node)、类型节点 (_type)、常量节点 (_cst)、表达式节点 (_expr)、列表节点 (_list)、其它节点。每个节点都是以 “@” 符号开始跟上节点的索引，接着是节点类型和信息，包括变量名、类型、所属函数、大小等等，这些信息的值有的是直接显示的，有的是对应节点的索引值。下图为GCC生成的抽象语法树部分节点内容：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxksdqd16ij30fr06ldgg.jpg"></p></li><li><p>GCC版本不同，对应的生成抽象语法树命令也不同。文中使用-fdump-translation-unit 命令将整个翻译单元的树结构表示形式转储到文件中。生成与源文件名相同的 tu 文件，同时允许调用者以翻译单元 (TU) 表的形式提取这些信息。GCC 直接生成的抽象语法树文本包含了大量的冗余信息，如果直接对原始文本进行解析不仅会降低效率，还可能影响分析的准确率。因此需要对原始的抽象语法树进行重建。重建的主要方法主要是由预处理、标准化、构建树三个方面组成。下图为重建AST流程:</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxksolwx6qj30dh0haq3e.jpg" style="zoom: 67%;" /></li><li><p>原始的 tu 文本由多个节点组成，每个节点都是由标号、节点标识、属性组成。首先要读取 tu 文件，以 “\n@” 为分界符将原始文本分成数个节点，再将其放入一个列表。接着遍历列表，处理每一个节点，将其转换为一个节点属性字典，处理后进行实例化。然后处理实例中 “attr” 字符串，其中属性节点可以有多个，它不仅表示属性，也表示子节点。针对本文所需的可视化需求添加相应实例属性，构建树的结构。最后将处理后的节点重新放入节点列表。</p></li><li><p>抽象语法树可视化方面，使用OrgChart组件，提供 JSON 格式的数据源将其渲染为树形结构。重建后的抽象语法树还不能直接作为可视界面的数据源，需要进行处理后才能使用。数据处理主要操作是将原数据节点内容进行区分，通过添加字段来区分该节点是否为虚节点，并控制节点的显示样式。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxkst9j7xpj30fr074jro.jpg" style="zoom:88%;" /></li><li><p>文中提供两段相似的源代码，两段代码的功能都是用循环结构打印从 1 到 3 的三个数字，而第一段代码定义的变量名为 i，且使用 for 循环。第二段代码定义变量名为 j，使用的是 while 循环。两种循环结构生成的抽象语法树类似，且不同的的变量名对抽象语法树的结构不产生影响。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxksxs07f1j30y50u040x.jpg" style="zoom:50%;" /></li></ol><p>[2] </p><ol><li><p>抽象语法树包括表示非保留字终结符的叶子结点和表示语法结构的中间结点组成。抽象语法树 可以进一步完善，可以包含表现语义关系的连接如定义使用链等及类型信息和符号表，并将其视为抽象语法树的结点来对待。最后的抽象语法树将包含所有的、编译器前端从源代码所得到的相关信息并且能够完全体现源程序的语法结构.</p></li><li><p>词法分析 (Lexical analysis) 提供了语法树所需要的符号结点，如常量和名字。语法分析 (Parsing) 则提供了含有代表相应语法结构的中间结点的抽象语法树。语义分析 (Semantic analysis) 最后经过对名字和操作符的处理将语法树转变为一种包括类型信息和符号表的标准形式并将它们连接成树形结构。抽象语法树是编译器前端的最基本的输出。</p></li><li><p>C/C++语法分析技术是建立一个抽象语法树的前提和基础。C/C++语法分析对标记的处理分为3 种，一种处理标志符，一种处理声明，一种处理较难分析的结构体。</p></li><li><p>举例：static unsigned int  * a[5]，b=1;这是一个C/C++中的声明，以一个标志符链表 (static unsigned int) 开始。这个标志符链表描述了变量链表的属性 (static) 和 ‘‘base type” (unsigned int)。标志符链表通常跟随着一个所谓的个体声明 链表。一个个体声明描述了变量的名字 (a和b)，它的类型( * a[5]表示指针数组)，和一个初始值(1)。 通常变量的名字可以在类型描述( * a[5])中找到。然而，在个体声明中的类型描述是不完整的因为‘‘base type”被遗漏了。“base type” 在标志符链表中给出了。在我们的例子中变量a的完整类型应该 是“array of pointer to unsigned int”即“无符号整型指针数组”。画出了一个树图来分别完整的描述一个变量的名字(name)和类型(type)。在上面的例子中就可以产生一个树，如下：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxktb238uej31640su0vi.jpg" style="zoom:45%;" /><p>​        在上图中，变量a的声明从类型结点var_decl开始。a的类型通过类型结点array，pointer及simple type描述。变量b的声明从类型结点init.-decl开始。b的类型仅仅通过类型simple_type来描述。</p></li><li><p>为了对抽象语法树进行完善和改进，语义分析是必要的。在一个编译器中有很多方法来进行语义分析。大部分方法都是由抽象语法树驱动的。一个常用的方法是使用属性文法。另一个可行的方法是为每一种结点定义一个语义分析程序。在这种情况下语义分析是通 过调用对应的树的根结点的处理程序，该处理程序又调用根结点的孩子结点的处理程序来完成的。</p><p>我们采取的语义分析方法是上面两种方法的折中。我们使用一个定义程序来定义抽象语法树上 每一种类型的结点的基本语义。部分语义处理中使用的值作为属性被有效的存放在抽象语法树上。 那些共有属性成为最终树的一部分，而其他的私有属性则仅用来进行语义分析。</p></li></ol><p>[3]</p><ol><li><p>GCC编译器分为前端和后端两个部分。前端完成语法分析，生成 AST，后端则将 AST转换为 RTL(Register Transfer Language)中间语言，进行优化和代码生成。在语法分析阶段， 源程序中所有实体都被翻译成抽象语法树中各种类型的树结点。GCC 的抽象语法树使用相同的类型 tree 来表示，树(tree) 是中间表示所使用的核心数据结构。一个 tree类型的变量可以 是一个树结点，也可以是一棵子树。</p></li><li><p>建立抽象语法树流程</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxktkhi6cdj30lu0jct9r.jpg" style="zoom:50%;" /></li></ol><h4 id="三、下周工作重点及周计划（方案）"><a href="#三、下周工作重点及周计划（方案）" class="headerlink" title="三、下周工作重点及周计划（方案）"></a>三、下周工作重点及周计划（方案）</h4><ul><li><p>开始相关考试科目的复习</p></li><li><p>继续搭建商城项目，练习Vue框架</p></li><li><p>学习编译原理相关知识</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>BiweekReport</tag>
      
      <tag>抽象语法树</tag>
      
      <tag>软件过程管理</tag>
      
      <tag>Vue</tag>
      
      <tag>挑战杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Biweek Report 20211201~20211214</title>
    <link href="/2021/12/06/BiweekReport_20211201_20211214/"/>
    <url>/2021/12/06/BiweekReport_20211201_20211214/</url>
    
    <content type="html"><![CDATA[<h2 id="双周汇报"><a href="#双周汇报" class="headerlink" title="双周汇报"></a>双周汇报</h2><p>2021～2022学年第一学期  第13、14周（2021年12月01日～2021年12月14日）</p><p>汇报人：汤伟杰    汇报时间：2021年12月6日</p><h4 id="一、本周主要工作内容"><a href="#一、本周主要工作内容" class="headerlink" title="一、本周主要工作内容"></a>一、本周主要工作内容</h4><ul><li><p>文献阅读：阅读了有关于缺陷定位、静态分析（尤其针对C语言）等相关的文献资料。</p></li><li><p>学习工作：学习了基于Promise的http库axios的使用、配置以及模块封装；继续学习Vue框架，基于Vue搭建一个商场项目，项目地址：<a href="https://github.com/leibaio/supermall">https://github.com/leibaio/supermall</a></p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx1xc8u53bj31ka0u0gq7.jpg" style="zoom: 33%;"/><p>开始了解编译原理、软件静态分析相关知识；学习非关系型数据库Mongo相关知识；参加学校华为中国芯技术大赛，学习鲲鹏软件迁移相关知识；</p></li></ul><h4 id="二、阅读文献笔记及总结"><a href="#二、阅读文献笔记及总结" class="headerlink" title="二、阅读文献笔记及总结"></a>二、阅读文献笔记及总结</h4><h5 id="文献："><a href="#文献：" class="headerlink" title="文献："></a>文献：</h5><p>[1] 方登辉. 基于抽象语法树的代码静态缺陷检测工具开发[D].北京邮电大学,2018.</p><p>[2] 刘海燕,杨洪路,王崛.C源代码静态安全检查技术[J].计算机工程,2004(02):28-30.</p><p>[3] 张亚楠,谢冬红,邵学彬.静态代码缺陷定位技术研究[J].信息与电脑(理论版),2017(23):16-19.</p><h5 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h5><p>[1]</p><ol><li><p>文章完成了基于抽象语法树的静态代码检测工具的开发，使用Clang编译器将源代码转化为抽象语法树，分析缺陷代码和正常代码的差异性，记录区分差异性的关键信息，利用这些信息基于GJB安全规范和PVS缺陷库构建检测规则，之后便利语法树，遍历过程调用规则检测，记录违反规则的代码片段及错误信息，生成测试报告。</p></li><li><p>软件测试分类</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx47litsmhj30u00v5di8.jpg" style="zoom:33%;" /></li><li><p>针对缺陷间的差异性，很难找到统一的检测规则，为了解决问题，文章使用基于规则的检测方式，针对每条缺陷进行单独构造定制化检测规则。使用TDD开发模式，文章具体内容包括：缺陷库的构建；定制化检测规则的制定；基于测试驱动开发校验每条规则；开放测试；</p></li><li><p>文章中使用开源框架OCLINT构建一个静态检测工具，相应的检测架构如下：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx482sx8tzj313e0o80vs.jpg" style="zoom:33%;" /><p>​    1）输入：规则库根据《GJB5369-2005航天型号软件C语言安全子集》代码编写规范和《PVS-Studio缺陷集》代码集合构成；测试代码库由测试人员依据检测规则构成，分为正常用例和缺陷实例。</p><p>​    2）处理引擎：使用开源框架OCLINT。框架底层使用LLVM作为编译处理工具，使用Clang编译器将源代码转化为抽象语法树；分析缺陷代码和正常代码的差异性，记录区分差异性的关键信息；遍历语法树，提取关键信息；使用检测规则扫描代码，获取关键信息；检测是否违背设定，记录违背缺陷的信息，生成报告。</p><p>​    3）输出：提供检测报告。包括源文件路径、缺陷行列位置、违反级别、违反的的规则类型、具体的规则名和提示的错误信息。</p></li><li><p>静态扫描流程：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4kxmxce2j30b00igq3h.jpg" style="zoom:50%;" /><p>测试系统的功能：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4l1yd3tfj30gy0dcq3i.jpg" style="zoom:45%;" /></li><li><p>静态分析工具实现：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4l468gnyj30d80cejrq.jpg" style="zoom:50%;" /><p>工具检测过程：首先项目检查前，对C/C++工程文件进行解析，获取编译项和依赖库，生成编译数据库，然后将编译数据库中每个文件使用clang编译器转化为抽象语法树，之后遍历抽象语法树并加载规则库中每条规则，最后规则将遍历语法树中获取的信息进行分析，判断是否违背规则，并将违背信息汇总生成测试报告。</p><p>具体实现包括：1）规则集的创建；2）将规则封装为第三方动态库。使用OCLINT命令将编写的规则库转换为动态调用库；3）工具的创建。使用OCLINT命令将编写的代码生成可执行文件，添加到系统路径。</p></li><li><p>抽象语法树是编译器经过语义分析后插入语义信息生成的，包含源代码执行逻辑的全部信息。是基于抽象语法结构将源代码转化为树形结构的一种表示方式，描述如何从文法结构推导程序语言中的语句的过程。下图为辗转相除法源代码和对应的抽象语法树结构：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4leq7k9tj30o60we40d.jpg" style="zoom:38%;" /><pre><code>  根结点为语句序列，表示程序入口。叶节点表示终止符，就是源代码中的标识符。编译器在词法分析后获得源代码的基本单元，经过语法分析获得源代码的执行流程生成抽象语法树。每条语法规则代表一种语句类型，以父节点生成，内部执行逻辑以父节点为根节点在孩子节点展开。</code></pre></li><li><p>抽象语法树构造：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4ljwau6xj30oo03mq34.jpg" style="zoom:50%;" /><p>经过词法、语法和语义三个阶段分析生成。语法树结构是对源代码高层次语义理解的结果，包含文法和语义信息。</p></li><li><p>文章分别介绍从语法树中提取上下文信息、提取程序结构信息、提取控制流信息、提取数据流信息四类信息。通过提取信息和具体缺陷结合，将缺陷大致分为七种类型：重复代码错误、数值范围、越界、控制流、数据流、函数调用、代码格式，以此展开依次进行描述。</p></li><li><p>规则构建：</p></li></ol>   <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx4lr64owxj30j20akgm4.jpg" style="zoom:50%;" /><p>   规则构建实际是缺陷特点和语法树信息融合过程。整体架构分为分析设计、编码实现和测试校验三个部分。规则构建具体内容：1）确定规则基本信息  2）分析缺陷代码结构，给出算法思路  3）规则实现及有效性检测。文章使用基于GoogleTest测试框架编写测试用例对编写规则进行测试。</p><p>[2] [3]</p><ol><li>静态代码缺陷分类：缓冲区溢出、空指针引用异常、数据类型转换异常、整数溢出漏洞、内存泄露</li><li>静态分析技术：词法分析、语义分析、控制流分析、数据流分析</li></ol><h4 id="三、下周工作重点及周计划（方案）"><a href="#三、下周工作重点及周计划（方案）" class="headerlink" title="三、下周工作重点及周计划（方案）"></a>三、下周工作重点及周计划（方案）</h4><ul><li><p>继续阅读有关于缺陷定位的文献资料，针对本次报告第一篇论文涉及知识点进行深入研究</p></li><li><p>学习编译原理、程序静态分析相关课程，对于抽象语法树进行了解</p></li><li><p>继续搭建商城项目，练习Vue框架</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>BiweekReport</tag>
      
      <tag>静态分析</tag>
      
      <tag>规则检测</tag>
      
      <tag>抽象语法树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Biweek Report 20211116~20211130</title>
    <link href="/2021/11/22/BiweekReport_20211116_20211130/"/>
    <url>/2021/11/22/BiweekReport_20211116_20211130/</url>
    
    <content type="html"><![CDATA[<h2 id="双周汇报"><a href="#双周汇报" class="headerlink" title="双周汇报"></a>双周汇报</h2><p>2021～2022学年第一学期  第11、12周（2021年11月16日～2021年11月30日）</p><p>汇报人：汤伟杰    汇报时间：2021年11月22日</p><h4 id="一、本周主要工作内容"><a href="#一、本周主要工作内容" class="headerlink" title="一、本周主要工作内容"></a>一、本周主要工作内容</h4><ul><li>文献阅读：阅读了一些有关于缺陷定位、静态分析、程序规约、信息检索等相关的文献资料。</li><li>学习工作：使用了 Github Pages 和 Hexo 搭建了个人博客网站 <a href="https://leibaio.space/">leibaio.space</a> ；和同组同学报名参加挑战杯创业赛，根据研二师兄的基于 EAIDK-310 的集成化小车设计加设部分功能进行包装成产品；和本科同学组队参加外包服务大赛，项目将使用 JavaEE + Linux + MySQL 构建一个 PDF 转 EPUB 工具；</li></ul><h4 id="二、阅读文献笔记及总结"><a href="#二、阅读文献笔记及总结" class="headerlink" title="二、阅读文献笔记及总结"></a>二、阅读文献笔记及总结</h4><h5 id="文献："><a href="#文献：" class="headerlink" title="文献："></a>文献：</h5><p>[1] E. Giger, M. D’Ambros, M. Pinzger and H. C. Gall, “Method-level bug prediction,” Proceedings of the 2012 ACM-IEEE International Symposium on Empirical Software Engineering and Measurement, 2012, pp. 171-180, doi: 10.1145/2372251.2372285.</p><p>[2] 曹鹤玲,刘昱,赵晨阳,王玉华.程序缺陷自动修复研究进展及关键问题[J/OL].小型微型计算机系统:1-13[2021-11-13].</p><p>[3] 李政亮,陈翔,蒋智威,顾庆.基于信息检索的软件缺陷定位方法综述[J].软件学报,2021,32(02):247-276.</p><h5 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h5><p>[1]</p><p>[2]</p><ol><li><p>程序缺陷自动修复是针对程序中存在的缺陷，自动生成相应的程序补丁，进而使程序恢复正常运行。根据补丁生成方法的不同，可以分为基于搜索的、基于语义的、基于机器学习的以及基于错误报告驱动的4类程序缺陷自动修复方法。</p></li><li><p>程序缺陷自动修复研究框架：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwkjgl2d1lj30k00ck3zl.jpg" style="zoom: 67%;" /><p>定位阶段可以通过缺陷定位策略找出可疑位置，定位方法可以分为动态和静态两种缺陷定位方法。</p><p>（1）动态：通过对测试用例的执行行为和运行结果分析，基于特定模型进行定位缺陷语句的可能位置，主流是基于频谱的缺陷定位，通过执行测试用例获取程序频谱，而后分析频谱定位程序缺陷。</p><p>（2）静态：通过分析缺陷报告和程序模块的文本内容并提取特征，基于特定模型确定可疑的程序语句，不需要执行测试用例，不会受到程序规模和编程语言等因素的影响，基于信息检索的缺陷定位（Information Retrieval-Based Bug Localization，IRBL）是目前静态缺陷定位研究中的热点，广泛用于基于错误报告驱动的程序缺陷自动修复方法。补丁生成阶段按照一定的修复规则逐个对可疑缺陷代码进行处理，生成相应补丁。</p></li><li><p>在验证时，一方面要检测补丁是否成功修复原有缺陷，另一方面要检验原有程序是否被破坏。对补丁进行验证的开销往往较大，利用候选补丁排序技术有助于提高修复效率和缩减验证成本。</p></li><li><p>基于搜索的程序缺陷自动修复方法：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwmjv2qvdoj30zu08ujsi.jpg" style="zoom: 43%;" /><p>利用了基于搜索的软件工程（Search Based Software Engineering，SBSE）中的蚁群算法、粒子群优化、遗传算法和模拟退火等算法。核心思想：在一个搜索空间内寻找补丁并进行正确性验证的过程。</p><p>存在问题：1）设置一个合适的空间，空间过大是导致效率低下，并会产生大量疑似补丁。过小会导致空间可能不存在正确补丁；2）生成的补丁可能通过测试但是会违背程序语义，如何剔除是一个关键问题。3）测试用例的质量决定了定位缺陷的准确性以及验证补丁的正确性，如何生成一个高质量测试用例也是一个关键问题。</p></li><li><p>基于语义的程序缺陷自动修复方法：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwmkcxczyjj30ss0c83zs.jpg" style="zoom: 43%;" /><p>正确性通常高于基于搜索的程序缺陷自动修复。首先定位到可以的缺陷实体，对实体进行排序；其次生成含有缺陷实体的输入输出预期值；然后收集程序运行信息，提取补丁需要满足的约束；最后将修复约束作为合成补丁的规约，并用约束求解器生成补丁。相比于基于搜索的，补丁基本都能通过验证。</p><p>存在问题：1）通过约束生成补丁，生成正确补丁的概率更高，但需要更多的程序信息，并且面临算法执行时间长、部署和实施困难的问题；2）方法建立在“补丁通过测试用例，则为正确补丁”，不可避免会产生过拟合问题；3）在小规模程序上展现出良好修复效果，由于大多使用符号执行以及约束求解问题，难以应用在较为复杂的程序上。</p></li><li><p>基于机器学习的程序缺陷自动修复方法：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwml03lpt7j31a00dyac9.jpg" style="zoom:43%;" /><p>可以有效解决基于搜索的和基于语义的局限。首先获取数据集，进行数据预处理并将数据送至修复模型；其次结合机器学习技术对模型进行训练；然后用训练好的模型为待修复程序生成候选补丁；最后对候选补丁进行排序和正确性验证。</p><p>存在问题：1）源代码不同于自然语言，原始数据相当嘈杂，会对训练产生极大程序噪音。如何过滤原始数据是基于机器学习面临的一个关键问题；2）自然语言中，类似于标点符号的错误是可以接受的，但在编程语言中，标识符、数字等的误用会导致编译器产生错误，并且依赖关系也更长；3）由于变量、常量等定义的任意性，且字母的大小写在编程语言中有不同含义，所以需要处理的词汇量巨大，如何减小需要处理的词汇数据也是面临的关键问题。</p></li><li><p>基于错误报告驱动的程序缺陷自动修复方法</p><p>大多实际情况中，有关测试用例的通用假设不存在，许多测试不能通过测试套件挖掘，使用基于错误报告的可以应对，因为错误报告中含有丰富的关于程序执行以及用户反馈的错误信息。最大的优势是不需要对测试用例进行假设，一定程度上增加了此类方法的实际可用性。</p><p>存在问题：1）第一阶段是对错误报告进行解析、筛选和分类，然而错误报告的数量通常较多，需要耗费大量资源，设计一个更加合理高效的算法是面临的一个关键问题；2）为了从错误报告生成补丁，需要提取关于错误的详细信息，现有的提取技术智能获取到简单的错误描述，如何改进现有技术以获取全面的错误描述进而得到错误产生的根本原因也是一个关键问题。</p></li><li><p>缺陷库</p><p>程序缺陷自动修复的检验离不开缺陷高质量的缺陷库。高质量的缺陷库需要具备完备的测试集，且要求缺陷的来源必须是真实的项目。下表给出了一些缺陷库对应的相关信息。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwmof964muj31230u0jwu.jpg" style="zoom:50%;" /></li></ol><p>[3]</p><ol><li><p>基于信息检索的软件缺陷定位是当前软件缺陷定位的研究热点，主要分析缺陷报告文本和程序模块代码，通过计算缺陷报告和程序模块之间的相似度，选取与缺陷报告相似度最高的若干程序模块，将其推荐给开发人员。</p></li><li><p>对需求理解的偏差、不合理的软件开发过程、开发人员的疏忽，均有可能在项目中引入软件缺陷。传统的调试方法是借助手工，可以代码处设置断点，重复执行失败的测试用例，定位代价高、对缺陷报告信息利用不充分、费时费力。</p></li><li><p>动态缺陷定位和静态缺陷定位，概念同上述 [2] 2，静态缺陷中基于信息检索的缺陷定位（information retrieval-based bug localization，简称IRBL）是目前静态缺陷定位研究热点，也是本文重点关注的研究问题。</p></li><li><p>IRBL可视为概念定位（concern localization）或者特征定位（feature localization）的一个特例，当需要定位的概念或特征都为缺陷时，又被称为缺陷定位。从 IEEE Explore、ACM Digital Library、Elsevier、Springer、CNKI 等学术论文数据库进行检索，关键词包括 bug localization、fault localization、information retrieval、bug localisation等，然后通过人工审查。2013年后，随着公开的数据集和共享代码不断增多，针对IRBL方法的研究逐渐成为静态缺陷定位领域的主流研究方向。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwn997y5hij30mq0fimxr.jpg" style="zoom:50%;" /></li><li><p>IRBL针对一个缺陷报告，尝试定位到可能包含缺陷的程序模块，其输入为缺陷报告和所有候选程序模块，通过建立程序模块语料库、建立索引、构建查询、检索和排序，推荐给开发人员一个有序列表（按照含有缺陷的可能性从高到低排序）。</p><p>缺陷报告一般包含标题(title)、描述(description)、评论(comment)、产品(product)、组件(component)、版本号(version)和提交时间等信息。研究框架如下图：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwn9fifgywj30v60j8myr.jpg" style="zoom:43%;" /><p>IRBL过程包括：模型构建阶段和模型应用阶段。</p><p>模型构建包括：1）挖掘缺陷跟踪系统、版本控制系统、API文档等数据源，从中搜集缺陷报告、程序模块和提交日志等信息，建立缺陷报告与与程序模块的关联，构建出缺陷定位数据集；同时IRBL的输入也由所搜集的数据源信息决定。2）设计出衡量缺陷报告与程序模块相关度的特征，分析程序模块含有缺陷的概率，借助这些特征构建出IRBL（缺陷定位）模型。</p><p>模型应用阶段，处理一个新的缺陷报告，基于前一阶段流程提取特征，并用训练好的缺陷定位模型完成对该缺陷报告的定位，将有序列表推荐给开发人员。根据应用场景不同需求，缺陷定位粒度和结果不同，输入信息、特征提取方式和检索过程都会不同，生成不同的有序列表。</p></li><li><p>通过上述分析，影响缺陷定位性能的3个重要因素：数据源、检索模型、场景应用。</p></li><li><p>数据源分析：</p><p>不同数据源划分为三类：（1）缺陷报告和程序模块；（2）项目元数据；（3）测试用例的执行信息；</p><p>从缺陷跟踪系统挖掘缺陷报告信息；从版本控制系统（如Git、SVN或CSV等）挖掘程序模块代码和元数据（即版本历史信息和代码变更信息）；测试用例通过对项目运行多个测试用例生成并获取。</p><p>1）原始的缺陷报告和程序模块具有很多噪音词汇及数据。进行数据预处理，包括文本标准化（text normalization）、停用词（stopword）移除以及词干提取（stemming）这3步。</p><ul><li>文本标准化：从文档中移除特殊字符和标点，将文档切分成不连续的单词，源代码的标识符，依据驼峰式分割（camel case splitting）进一步切分，如 “processFile” 可被切分为 “process” 和 “file”。</li><li>停用词移除：停用词指在文档中频繁出现，但在区分不同文档中作用极小的单词，如 “a“ ”on“等，对程序模块而言，需要移除如 “int” “private” 等。</li><li>词干提取：将单词转换成对应的词干形式，如 “localized” “localization” “localize” 和 “locally” 都可还原为词干 “local”。</li></ul><p>2）缺陷报告与程序模块相关性度量主要从3个角度出发：文本信息、堆栈跟踪、相似缺陷报告。</p><ul><li>文本信息：这类信息的常见输入是缺陷报告的总结和描述以及程序模块的文本内容，可以采用文本检索方法直接计算出缺陷报告和程序模块之间的相关性，也可基于语义模型计算。</li><li>堆栈跟踪：缺陷报告质量有高有低，有时缺陷报告中会包含程序执行失败后的堆栈跟踪信息，开发人员首先检查堆栈跟踪涉及到的程序模块进行缺陷定位。使用这一额外信息，可以有效提高缺陷定位的性能，通常作为计算缺陷报告和程序模块相关性的补充。</li><li>相似缺陷报告：从已修复的缺陷报告中搜索出与当前缺陷报告相似的缺陷报告，相似缺陷报告评分作为增强缺陷报告与缺陷模块相关性的评分。</li></ul><p>3） 程序模块缺陷概率：（1）从程序模块调用关系；（2）代码异味（code smell）</p></li><li><p>检索模型：</p><p>基于通用检索模型的方法：（1）向量空间模型（VSM）；（2）主题模型，有潜在语义分析（latent semantic analysis）和隐含狄利克雷分布；（3）概率检索模型，包括SUM（smoothed unigram model）和 BM25；</p><p>优化方法：（1）基于输入源拓展的方法；（2）基于优化函数的方法；（3）基于查询重构的方法；</p></li><li><p>场景应用：根据不同的场景需求，开发人员对缺陷定位粒度和准确率的需求不同，基于IRBL的定位粒度，IRBL方法输出级别可分为文件（类）级别、函数级别、语句级别和代码变更级别。下图为IRBL不同定位粒度方法的论文数统计。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwnb8a4obqj30ma0b2dg9.jpg" style="zoom:43%;" /></li><li><p>性能评测指标分析：</p><p>文章对已有 IRBL 研究中常用的性能评测指标的累计使用次数进行了统计，并从大到小进行排序；同时给出了每个指标的首次使用时间（包括对应的参考文献），最终结果如下：</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwnbbkqv35j316809240c.jpg" style="zoom:43%;" /></li><li><p>评价数据集总结：</p><p>因开源软件项目数据获取相对容易，研究人员一般使用开源项目进行科学研究，下表为评测数据集的使用情况统计。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwnbca0y0kj316i0bego5.jpg" style="zoom:43%;" /></li></ol><h4 id="三、下周工作重点及周计划（方案）"><a href="#三、下周工作重点及周计划（方案）" class="headerlink" title="三、下周工作重点及周计划（方案）"></a>三、下周工作重点及周计划（方案）</h4><ul><li>部分32课时考试科目如英语、自然辩证法等开始复习</li><li>继续阅读有关于缺陷定位的文献资料，主要针对Ｃ语言的源程序如何定位缺陷</li><li>根据参加项目，对于相关技术栈进行学习补充</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>BiweekReport</tag>
      
      <tag>缺陷定位</tag>
      
      <tag>静态分析</tag>
      
      <tag>程序规约</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Biweek Report 20211101~20211115</title>
    <link href="/2021/11/09/BiweekReport_20211101_20211115/"/>
    <url>/2021/11/09/BiweekReport_20211101_20211115/</url>
    
    <content type="html"><![CDATA[<h2 id="双周汇报"><a href="#双周汇报" class="headerlink" title="双周汇报"></a>双周汇报</h2><p>2021～2022学年第一学期  第9、10周（2021年11月1日～2021年11月15日）</p><p>汇报人：汤伟杰    汇报时间：2021年11月8日</p><h4 id="一、本周主要工作内容"><a href="#一、本周主要工作内容" class="headerlink" title="一、本周主要工作内容"></a>一、本周主要工作内容</h4><ul><li><p>文献阅读：阅读了一些有关于功能自动化测试、云测试的文献资料，了解了一些自动化回归测试的概念和基本流程，开源web自动化工具Selenium。</p></li><li><p>学习工作：</p><p>学习了文档排版系统LaTex，并用其进行部分课程作业的编写；</p><p>网络安全课程作业选择了WEB前端安全的分析，对于WEB前端安全的一些攻击防御方式有所了解；</p><p>开始学习一个基于Promise的HTTP库Axios；</p><p>找到一个软件测试教程，开始对各类测试模型进行了解。</p><p><a href="https://codingdict.com/article/28668">https://codingdict.com/article/28668</a></p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw8q845q6cj30ko12ugnl.jpg" style="zoom:30%;" /></li></ul><h4 id="二、阅读文献笔记及总结"><a href="#二、阅读文献笔记及总结" class="headerlink" title="二、阅读文献笔记及总结"></a>二、阅读文献笔记及总结</h4><h5 id="文献："><a href="#文献：" class="headerlink" title="文献："></a>文献：</h5><p>[1]马天鸣,梁琛.Selenium在电话自动拨测系统中的应用[J].计算机技术与发展,2021,31(10):141-145+153.</p><p>[2]彭珲,耿杰恒,张晓娜,李晓利.软件云测试平台的设计与实现技术[J].电脑编程技巧与维护,2021(08):13-15.</p><p>[3]以Selenium+Chrome为核心的数据采集系统设计[J]. 黄孝伦,王东.  计算机技术与发展. 2020(09).</p><h5 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h5><p>[1]</p><ol><li><p>在项目周期长，模块功能复杂的情况下，采用手工方式对系统功能进行多次重复的验证时，会消耗大量时间，增加测试成本。因此，选择正确的回归测试策略来改进测试的效率和有效性时很有必要的。</p></li><li><p>电话自动拨测系统需求变动不频繁、项目周期长、UI界面稳定变动少。-&gt; 引入UI自动化测试。</p></li><li><p>selenium+python，测试过程：<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw91ndg10pj30mw04uglu.jpg" style="zoom:50%;" /></p></li><li><p>测试脚本编写过程中，系统登录验证码有四种解决方法：（1）去掉这部分代码（安全风险），（2）使用一个万能验证码（需要开发的协助），（3）通过cookie直接登录，避开验证码（无法对验证码进行自动化测试），（4）通过截取验证码区域，使用webdriver。使用验证码id定位到该验证码的位置，获取验证码的位置和大小，在截取后，使之灰度并增强饱和度，识别图片内容转化为字符串。（安全，可行，✅）</p></li><li><p>单元测试对技术要求高，白盒测试人员和软件开发人员才能胜任，使用单元测试框架使得过程简单化。系统中单元测试框架使用python中的unittest:</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw91ot4ksyj30k60cy0t9.jpg" style="zoom:50%;" /></li><li><p>页面定位元素时，系统主要使用id、name和class属性来查找元素。上述无法生效，使用XPath（XML路径语言）进行绝对或相对定位。</p></li><li><p>操作页面时，使用Webdriver进行和浏览器的交互。没有定位到元素时，可能没有找到标签，也可能网速原因没有及时加载，会导致程序报错，设置线程等待：隐式等待（异步，如网络延迟，Ajax动态加载元素响应时间不一致）、显式等待（同步）；</p></li><li><p>使用断言进行测试优化，可以使用unittest的拓展HMTLTestRunner脚本实现生成测试报告，使用python的第三方库yagmail实现自动发送邮件功能等。</p></li></ol><p>[2]</p><ol><li>大型分布式软件测试面临的难题：（1）环境构建难。自身结构和分布式运行流程复杂，构建其运行的基础网络环境和实际的网络环境信道不一定相同。（2）驱动运行难。不同岗位的操作在统一的任务驱动下，协调操作分布式系统软件运行共同完成统一目标任务。对于软件测试，很难每个席位配置一个操作人员。其次，被测分布式系统外围系统和设计会产生数据。需要考虑不同节点信息的时序、关联。（3）测试评估难。大型分布式系统出了需要考虑数据之间的关联性、时效性、耦合性外，还要考虑数据的可采集性，有些数据外界难以获取，有一些是以加密形式存在的。这些导致复杂分布式系统测试的数据采集和分析困难。</li><li>根据被测软件特点和软件测评任务特点，建立软件云测平台：分为三个系统：云基础分系统、测试运行支撑分系统、测试数据采集与分析分系统。<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw91p9bm1pj30o20c0abm.jpg"></li><li>云测试平台运行设计两种不同的工作流程：浏览器/服务器，客户端/服务器。</li><li>运行逻辑：step1: 创建被测对象，包括程序、各方面文档内容上传到库；step2:用户申请测试对象进行出库，创建具体任务，由云基础平台负责环境设计、定制、测试需要的工具以及数据采集的Agent；step3: 测试的数据由Agent采集，上传到系统中，进行存储、解析，再格式化存储，供数据综合分析模块使用。</li><li>测试平台数据流使用SpringCloud微服务框架，包括集群、配置中心、服务注册EUREKA、网关、路由。用户身份信息借助Shiro组件完成权限控制；远程客户端连通使用Socket协议；日志由SL4J完成处理；存储由MySQL集群完成；借助QUARTZ完成定时任务；借助Redis高速缓存完成对缓存的依赖。</li></ol><p>[3]</p><ol><li><p>医疗大数据系统数据庞大、系统异构。使用爬虫技术进行抓取指标数据，并按照要求进行数据清洗。</p></li><li><p>系统采用CS模式，服务器段负责接受数据交给监测平台存储和处理，客户端在各医院信息系统进行数据采集、清洗和传输。具体技术使用Selenium + ChromeDrive （Chrome的自动代理框架控制浏览器）构建网络爬虫。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw91pl86lqj30g20do3z2.jpg" style="zoom:50%;" /></li><li><p>和传统爬虫不同：系统根据指标特点构建爬虫。由于各个医院采用不同厂商信息系统，系统、数据和存储之间存在异构，所以每个客户端通过配置获取每个页面的元素位置，然后抓取数据。程序运行客户端根据配置文件生成Java源码，然后调用javac编译。以此满足各医院自定义配置文件需求，解决异构问题。</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gw91pwezqmj30dq0lqwf6.jpg" style="zoom:50%;" /></li><li><p>URl以及登录信息配置：为提高响应速度，使用并行方式分别抓取相应系统中的数据，登录验证是爬虫抓取需要用户权限的数据的必要模块，在配置URL时，每一条URL对应一对用户名和密码，然后根据该凭证进行模拟登录。由于部分系统的session凭证设置时效，为解决这个问题，监测到异常时，重新模拟登录，获取新的session，同时抓取数据采用Headless模式。</p></li><li><p>数据抓取：采用配置方式获取指标数据在系统页面的位置元素。虽然各个医院业务系统存在异构，但大体流程相同。因此根据不同的系统设计一个基本流程模板，在配置时根据模板进行调整。</p></li><li><p>数据存储和清洗：不断的抓取数据可能会影响医院业务的正常运行，因此抓取原始界面进行缓存，出现问题时读取缓存页面，不必重新抓取。数据清洗包括：(1). 指标汇总处理; (2). 数据描述一致性处理</p></li></ol><h4 id="三、下周工作重点及周计划（方案）"><a href="#三、下周工作重点及周计划（方案）" class="headerlink" title="三、下周工作重点及周计划（方案）"></a>三、下周工作重点及周计划（方案）</h4><ul><li>继续学习LaTex文档排版系统，在后面的作业以及文章中能够更加熟练使用</li><li>根据找到的软件测试教程文档，对于各个测试模型系统学习</li><li>根据11月3日泽众软件测试公司的产品介绍，对于当下企业在使用的测试技术进行了解</li><li>继续学习Axios，了解node.js中http请求以及响应等</li><li>继续学习Vue框架，熟悉状态管理模式Vuex</li><li>继续阅读自动化测试、云测试、测试优化、基于模型测试等相关文献</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>BiweekReport</tag>
      
      <tag>功能测试</tag>
      
      <tag>自动化测试</tag>
      
      <tag>云测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello, it&#39;s leibaio</title>
    <link href="/2021/11/09/hello/"/>
    <url>/2021/11/09/hello/</url>
    
    <content type="html"><![CDATA[<p>Welcome to my blog!  This is my very first post. </p><p>The website is built by <a href="https://pages.github.com/">Github Pages</a> and <a href="https://hexo.io/">Hexo</a>，using <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a> theme.</p>]]></content>
    
    
    
    <tags>
      
      <tag>hello</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
